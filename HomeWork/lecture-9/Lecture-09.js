// Выполнение JS-кода — однопоточное. Это значит, что в конкретный момент времени движок может выполнять не более одной строки кода. То есть вторая строка не будет выполнена, пока не выполнится первая.

// Такое выполнение кода (строка за строкой) называется синхронны

// Синхронный код понятный, его удобно читать, потому что он выполняется ровно так, как написан:
// АСД => byte-code
// console.log('A');
// console.log('B');
// console.log('C');
// const createCounter = () => {
// 	let counter = 0;
// 	function increment() {
// 		counter++
// 		console.log('Ты кликнул ' + counter)
// 	}
// 	return increment
// }
// const counter = createCounter()

// document.addEventListener('click', counter)
// // Выведется:
// // A
// // B
// // C
// const wait = (ms) => {
// 	const end = Date.now() + ms
// 	while (Date.now() < end) continue
// }

// wait(5000)
// console.log('Bye!') // через 5 секунд
// что такое движок v8 (google chrome, nodeJS, opera) хранит компилятор и среду выполнения

// Однако с ним могут возникать некоторые проблемы. Представим, что нам нужно выполнить какую-то операцию, требующую некоторого времени — например, напечатать в консоли приветствие, но не сразу, а через 5 секунд. Давайте напишем синхронную функцию wait() которая будет ждать кол-во мс передаваемых в параметр

// function greet() {
//   console.log("Hello! после wait")
// }

// wait(5000)
// greet()

// Через 5 секунд бездействия вывелось
// Hello!

// И всё вроде хорошо, приветствие бы действительно напечаталось спустя 5 секунд, однако проблема здесь в другом.
// Если мы запустили синхронную функцию задержки wait(), то движок ничем другим заниматься в это время не мог.
// Мы помним, что выполнение синхронного кода — строка за строкой. То есть пока wait() не выполнится до конца, к следующей строке интерпретатор не перейдёт.

// А это значит, что пока не пройдёт 5 секунд, и wait() не выполнится, мы вообще ничего сделать не сможем: ни вывести что-то в консоль ещё, ни выполнить другие функции

// Теперь попробуем решить эту же задачу, но так, чтобы наш код не блокировал выполнение. Для этого мы воспользуемся функцией setTimeout():

// API это интерфейс предоставленный для пользователя
// function greet() {
//   console.log("Hello! из таймера")
// }

// setTimeout(greet, 5000)
// console.log(`Вызов после запуска таймера`)
// wait(10000)
// Сначала выведется: «Вызов после запуска таймера», а через 5 секунд — «Hello!»
// Задача решена. В этот раз, однако, в эти «5 секунд молчания» мы можем выполнять другие действия.

// Возникает несколько вопросов:
// Почему вторая строка кода выполнилась до первой, если JS однопоточный?
// Куда девается setTimeout() на время, пока выполняется другой код?
// Как движок понимает, что пора выводить Hello!?

// Чтобы с этим разобраться, нам надо понять, как функции вызываются «под капотом».

// Стек вызовов:
// При вызове какой-то функции она попадает в так называемый стек вызовов.

// Стек — это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым (LIFO: last in, first out). Стек похож на стопку книг: та книга, которую мы кладём последней, находится сверху.

// const Stack = () => {
// 	const data = []

// 	function add(el) {
// 		data.push(el)
// 	}

// 	function remove() {
// 		data.pop()
// 	}
// 	function getData() {
// 		return [...data]
// 	}
// 	return {
// 		add, remove, getData
// 	}
// }

// const stack1 = Stack()
// stack1.add(1)
// stack1.add(2)
// stack1.add(3)
// console.log(stack1.getData())
// stack1.remove()
// stack1.add(1)
// console.log(stack1.getData())

// В стеке вызовов хранятся функции, до которых дошёл интерпретатор, и которые надо выполнить.

// function secondFunc() {
// 	console.log('Hi from second')
// }

// function outer() {
//   function inner() {
//     console.log("Hello!")
//   }

//   inner()
// }

// outer()
// secondFunc()
// stack1.add('outer') // outer

// stack1.add('inner')// outer inner

// stack1.add('console.log') // outer inner console.log

// stack1.remove() // outer inner
// stack1.remove() // outer
// stack1.remove() //

// stack1.add('secondFunc') // secondFunc
// stack1.add('console.log') // [secondFunc console.log]
// stack1.remove() // secondFunc
// stack1.remove() //

// function recursion () {
// 	if (true) {
// 		return
// 	}
// 	return recursion()
// }

// stack1.add('recursion')
// stack1.add('recursion')
// stack1.add('recursion')
// stack1.add('recursion') // recursion recursion recursion recursion
// stack1.remove() // recursion recursion recursion
// stack1.remove() // recursion recursion
// stack1.remove() // recursion
// stack1.remove()

// Вызываем функцию 1 — outer(), она попадает в стек:

// Стек:
// outer;

// Внутри функции outer вызываем функцию 2 — inner(), теперь в стеке 2 функции, потому что первая ещё не выполнилась до конца:

// Стек:
// inner;
// outer;

// Внутри функции inner вызываем функцию console.log(), теперь в стеке 3 функции:

// Стек:
// console.log;
// inner;
// outer;

// Как только console.log() выполнится, она уйдёт из стека, там останется 2 функции:

// Стек:
// inner;
// outer;

// Выполнившись, функция inner тоже уйдёт из стека, в нём останется лишь одна:

// outer;

// После выполнения всего блока стек станет пустым.

// дальше мы вызываем secondFunc

// Стек:
// secondFunc

// в функции secondFunc мы вызываем console.log

// Стек:
// console.log
// secondFunc

// Как только console.log() выполнится, она уйдёт из стека, там останется secondFunc функция:

// Стек:
// secondFunc

// и после выполнения стек снова станет пустым

// В синхронном коде в стеке хранится вся цепочка вызовов. Поэтому, например, рекурсия без базового случая может приводить к переполнению стека — в нём скапливается слишком большое количество вызовов.

// Теперь посмотрим, как ведёт себя стек вызовов при работе с асинхронным кодом:

// function greet() {
// 	console.log("Hello!")
// }

// function secFunc() {
// 	console.log('Hi from sec')
// }

// function main() {
//   setTimeout(greet, 5000)

//   console.log("Bye!")
// }

// main()
// secFunc()
// Вызываем функцию main().

// Стек:
// main;

// Скопировать
// Вызываем setTimeout().

// Стек:
// setTimeout;
// main;

// setTimeout завершился, он выходит из стека:

// Когда setTimeout исчезает из стека, он попадает в видимость Web API, где интерпретатор понимает, что внутри него есть функция greet, которую надо выполнить через 5 секунд: (пока можем пропустить рассмотрим это ниже)

// Стек:
// main;

// Вызываем console.log('Bye!'):

// Стек:
// console.log('Bye!');
// main;

// Его вызов завершён, он выходит из стека:

// Стек:
// main;

// Вызов main тоже завершён, стек становится пуст.

// дальше мы вызываем secFunc

// Стек:
// secFunc

// в функции secFunc мы вызываем console.log

// Стек:
// console.log
// secFunc

// Как только console.log() выполнится, она уйдёт из стека, там останется secondFunc функция:

// Стек:
// secFunc

// и после выполнения стек снова станет пустым

// Проходит около 5 секунд, Web API отправляет функцию greet в очередь задач, а от туда она попадает в стек:

// Стек:
// greet;

// Она вызывает console.log('Hello!'):

// Стек:
// console.log('Hello!');
// greet;

// Отработав, она уходит из стека:

// Стек:
// greet;

// После выполнения всего блока стек снова становится пустым.

// Первое, что бросается в глаза — setTimeout() завершается сразу, хотя колбэк внутри него ещё не отработал, более того, он даже ещё не был вызван! Здесь нам понадобится ещё одно понятие — цикл событий (event loop).

// Цикл событий
// Сперва откроем страшную правду, setTimeout() — это не JavaScript! 😱

// Ну... не совсем так, конечно. Функция setTimeout() не является частью JavaScript-движка, это по сути Web API, включённое в среду браузера как дополнительная функциональность.

// Эта дополнительная функциональность (Web API) берёт на себя работу с таймерами, интервалами, обработчиками событий. То есть когда мы регистрируем обработчик клика на кнопку — он попадает в окружение Web API. Именно оно знает, когда обработчик нужно вызвать.

// Управление тем, как должны вызываться функции Web API, берёт на себя цикл событий (Event loop).

// Цикл событий отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.

// Именно цикл событий ответственен за то, что setTimeout() пропал из стека в прошлом примере. Чтобы увидеть картину целиком, давайте перейдем на 136 строку и снова прочитаем код

// Заметьте, что стек вызовов и очередь задач называются именно стеком и очередью. Потому что вызовы из стека работают по принципу «последний зашёл, первый вышел» (LIFO: last in, first out), а в очереди — по принципу «первый зашёл, первый вышел» (FIFO: first in, first out).

// while (true) {
// 	// каждые 16 мс
// }
// Примеры стека и очереди
// Очередь — структура данных, в которой элементы упорядочены так, что первый попавший в очередь элемент покидает её первым.

// http://latentflip.com/loupe/

// Промисы (Promise)
// Промис — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале pending («ожидание»), затем — одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»). Состояние может быть изменено один раз

// для event loop промис работает так же, как колбэк: функция, которая должна выполниться (resolve или reject), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда потом — в стек вызова.

// В асинхронных задачах есть разделение между макрозадачами и микрозадачами. Колбэки в промисах попадают в очередь микрозадач, тогда как колбэк в setTimeout — в очередь макрозадач.

// Промисы придумали, чтобы организовывать асинхронный код последовательно.

// Promise.then().then().catch().finally()

// Асинхронные функции:
// Если коротко, асинхронные функции — функции, которые возвращают промисы.

// Асинхронная функция помечается специальным ключевым словом async:
function forPromise(resolved, rejected) {
	setTimeout(() => {
		const result = Math.random();
		if (result > 0.01) {
			resolved({ name: 'Bob3000' });
		}
		rejected('Some Error');
	}, 3000);
}

function forPromise1(resolved, rejected) {
	setTimeout(() => {
		const result = Math.random();
		if (result > 0.01) {
			resolved({ name: 'Bob2000' });
		}
		rejected('Some Error1');
	}, 2000);
}
function forPromise2(resolved, rejected) {
	setTimeout(() => {
		const result = Math.random();
		if (result > 0.01) {
			resolved({ name: 'Bob1000' });
		}
		rejected('Some Error2');
	}, 1000);
}

const pro = new Promise(forPromise);
const pro1 = new Promise(forPromise1);
const pro2 = new Promise(forPromise2);
// console.log('after call promise', pro)
// pro
// 	.then((res) => {
// 		console.log('Promise resolve ', pro)
// 		return res
// 	})
// 	.then((res) => {
// 		console.log('Show result of Promise ', res)
// 		return res.name
// 	})
// 	.then((name) => console.log('Show the name ', name))
// 	.catch((err) => console.log(err))
// 	.then(() => console.log('Promise rejected ', pro))
// 	.finally(() => console.log('Call always after finish promise'))

// console.log(pro)
// pro.then(() => console.log(pro)).catch(() =>console.log(pro));
// pro.then(console.log).catch(console.log);
// console.log('D');
// Promise.all([pro1,pro, pro2])
// 	.then((res) => console.log(res[1].name))
// 	.catch((err) => {console.log(err)})
Promise.race([pro1, pro, pro2])
	.then((res) => console.log(res))
	.catch((err) => {console.log(err)})
async function request() {}
const req = async () => {};

class SomeClass {
	async request() {}
}
console.log('Hi after Prom');
// Они всегда возвращают Промис. Даже если мы явно этого не указывали, как в примерах выше, при вызове они всё равно вернут промис.

request().then(() => {});

// Однако с асинхронными функциями можно не обращаться с then — есть более изящное решение.
// Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then или колбэков, с помощью ключевого слова await.

// async function loadPosts() {
//   const response = await fetch(`/api/posts/`)
//   const data = await response.json()
//   return data
// }

// В примере выше мы используем fetch внутри функции loadPosts.

// Все асинхронные функции внутри мы вызываем с await — таким образом промис, который функция возвращает, автоматически разворачивается, и мы получаем значение, которое внутри промиса было.

// Код чище и короче. У нас больше нет цепочек из then, вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код.

// Мы можем обрабатывать ошибки с try-catch. Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в try-catch:

// async function loadPosts() {
//   try {
//     const response = await fetch(`/api/posts/`)
//     const data = await response.json()
//     return data
//   } catch (e) {
//     console.log(e)
//   }
// }

// При этом в отличие от .catch() промисов, try-catch поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.

// Можно ставить брейкпоинты (точки останова). Для отладки мы можем поставить брейкпоинт куда угодно, он сработает.

// Promise.all и Promise.race.
// Ад колбэков (Callback-hell) Секция статьи "Ад колбэков (Callback-hell)"
// Нагляднее всего его можно показать на примере.

// Допустим, у нас есть ряд асинхронных задач, которые зависят друг от друга: то есть первая задача запускает по завершении вторую, вторая — третью и т. д.

// setTimeout(() => {
//   setTimeout(() => {
//     setTimeout(() => {
//       setTimeout(() => {
//         console.log("Hello!")
//       }, 5000)
//     }, 5000)
//   }, 5000)
// }, 5000)
